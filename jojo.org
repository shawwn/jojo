#+property: tangle jojo.cpp
#+title: jojo

* [todo-stack]

*** refactor tests

*** zero arity constructor is a global var stores the data

*** builtin true-t and false-t

*** builtin unit-t -- for testing

*** fix repr for *_o

*** case_jo_t

*** simple sexp -- using `vector <string>` -- without macro

*** quit using org-mode and separate code into files

    - to fix forward declarations

*** use cpp header file

* prolog

*** include

    #+begin_src cpp
    #include <iostream>
    #include <algorithm>
    #include <cassert>
    #include <memory>
    #include <vector>
    #include <array>
    #include <map>
    #include <set>
    #include <stack>
    #+end_src

*** using

    #+begin_src cpp
    using namespace std;
    #+end_src

* datatype

*** forward declaration

    #+begin_src cpp
    struct env_t;
    struct obj_t;
    struct jo_t;
    #+end_src

*** name_t

    #+begin_src cpp
    using name_t = string;
    #+end_src

*** name_vector_t

    #+begin_src cpp
    using name_vector_t = vector <name_t>;
    #+end_src

*** bind_t

    #+begin_src cpp
    using bind_t = pair <name_t, shared_ptr <obj_t>>;
    #+end_src

*** bind_vector_t

    #+begin_src cpp
    // index from end
    using bind_vector_t = vector <bind_t>;
    #+end_src

*** local_scope_t

    #+begin_src cpp
    // index from end
    using local_scope_t = vector <bind_vector_t>;
    #+end_src

*** jojo_t

    #+begin_src cpp
    using jojo_t = vector <jo_t *>;
    #+end_src

*** jo_t

    #+begin_src cpp
    struct jo_t
    {
        virtual void exe (env_t &env, local_scope_t &local_scope);
        virtual string repr (env_t &env);
    };
    #+end_src

*** tag_t

    #+begin_src cpp
    using tag_t = size_t;
    #+end_src

*** tag_name_vector

    #+begin_src cpp
    using tag_name_vector_t = vector <name_t>;
    #+end_src

*** tag_map

    #+begin_src cpp
    using tag_map_t = map <name_t, tag_t>;
    #+end_src

*** obj_t

    #+begin_src cpp
    struct obj_t
    {
        tag_t tag;
        virtual ~obj_t ();
        virtual void print (env_t &env);
        virtual void apply (env_t &env, size_t arity);
    };
    #+end_src

*** obj_map_t

    #+begin_src cpp
    using obj_map_t = map <name_t, shared_ptr <obj_t>>;
    #+end_src

*** obj_vector_t

    #+begin_src cpp
    using obj_vector_t = vector <shared_ptr <obj_t>>;
    #+end_src

*** frame_t

    #+begin_src cpp
    struct frame_t
    {
        size_t index;
        jojo_t jojo;
        local_scope_t local_scope;
        frame_t (jojo_t jojo, local_scope_t local_scope);
    };
    #+end_src

*** box_t

    #+begin_src cpp
    struct box_t
    {
        shared_ptr <obj_t> obj;
        bool empty_p;
        box_t ();
        box_t (shared_ptr <obj_t> obj);
    };
    #+end_src

*** box_map_t

    #+begin_src cpp
    using box_map_t = map <name_t, box_t *>;
    #+end_src

*** obj_stack_t

    #+begin_src cpp
    using obj_stack_t = stack <shared_ptr <obj_t>>;
    #+end_src

*** frame_stack_t

    #+begin_src cpp
    using frame_stack_t = stack <shared_ptr <frame_t>>;
    #+end_src

*** env_t

    #+begin_src cpp
    struct env_t
    {
        box_map_t box_map;
        obj_stack_t obj_stack;
        frame_stack_t frame_stack;
        tag_name_vector_t tag_name_vector;
        tag_map_t tag_map;
        void step ();
        void run ();
        void report ();
    };
    #+end_src

*** jo

***** lambda_jo_t

      #+begin_src cpp
      struct lambda_jo_t: jo_t
      {
          name_vector_t name_vector;
          jojo_t jojo;
          lambda_jo_t (name_vector_t name_vector, jojo_t jojo);
          void exe (env_t &env, local_scope_t &local_scope);
          string repr (env_t &env);
      };
      #+end_src

* obj

*** tag

***** tagging

      #+begin_src cpp
      tag_t
      tagging (env_t &env, name_t name)
      {
          auto it = env.tag_map.find (name);
          if (it != env.tag_map.end ()) {
              tag_t tag = it->second;
              return tag;
          }
          else {
              auto tag = env.tag_name_vector.size ();
              env.tag_map [name] = tag;
              env.tag_name_vector.push_back (name);
              return tag;
          }
      }
      #+end_src

***** name_of_tag

      #+begin_src cpp
      name_t
      name_of_tag (env_t &env, tag_t tag)
      {
          return env.tag_name_vector [tag];
      }
      #+end_src

*** local

***** bind_vector_print

      #+begin_src cpp
      void
      bind_vector_print (env_t &env, bind_vector_t bind_vector)
      {
          for (auto it = bind_vector.rbegin ();
               it != bind_vector.rend ();
               it++) {
              cout << "(#"
                   << distance(bind_vector.rbegin (), it)
                   << " ";
              cout << it->first
                   << " = ";
              auto obj = it->second;
              obj->print (env);
              cout << ") ";
          }
      }
      #+end_src

***** local_scope_print

      #+begin_src cpp
      void
      local_scope_print (env_t &env, local_scope_t local_scope)
      {
          cout << "- local_scope\n";
          for (auto it = local_scope.rbegin ();
               it != local_scope.rend ();
               it++) {
              cout << "  - level # "
                   << distance(local_scope.rbegin (), it)
                   << " : ";
              bind_vector_print (env, *it);
              cout << "\n";
          }
      }
      #+end_src

*** obj

***** obj_t::~obj_t

      #+begin_src cpp
      obj_t::~obj_t ()
      {
          // all classes that will be derived from
          // should have a virtual or protected destructor,
          // otherwise deleting an instance via a pointer
          // to a base class results in undefined behavior.
      }
      #+end_src

***** obj_t::print

      #+begin_src cpp
      void
      obj_t::print (env_t &env)
      {
          cout << name_of_tag (env, this->tag);
      }
      #+end_src

***** obj_t::apply

      #+begin_src cpp
      void
      obj_t::apply (env_t &env, size_t arity)
      {
          cout << "- fatal error : applying non applicable object" << "\n";
          exit (1);
      }
      #+end_src

*** lambda

***** number_of_obj_in_bind_vector

      #+begin_src cpp
      size_t
      number_of_obj_in_bind_vector (bind_vector_t &bind_vector)
      {
          size_t sum = 0;
          auto begin = bind_vector.begin ();
          auto end = bind_vector.end ();
          for (auto it = begin; it != end; it++)
              if (it->second)
                  sum++;
          return sum;
      }
      #+end_src

***** lambda_o

      #+begin_src cpp
      struct lambda_o: obj_t
      {
          lambda_jo_t *lambda_jo;
          bind_vector_t bind_vector;
          local_scope_t local_scope;
          lambda_o (env_t &env,
                    lambda_jo_t *lambda_jo,
                    bind_vector_t bind_vector,
                    local_scope_t local_scope);
          void apply (env_t &env, size_t arity);
      };
      #+end_src

***** lambda_o::lambda_o

      #+begin_src cpp
      lambda_o::
      lambda_o (env_t &env,
                lambda_jo_t *lambda_jo,
                bind_vector_t bind_vector,
                local_scope_t local_scope)
      {
          this->tag = tagging (env, "lambda-t");
          this->lambda_jo = lambda_jo;
          this->bind_vector = bind_vector;
          this->local_scope = local_scope;
      }
      #+end_src

***** bind_vector_insert_obj

      #+begin_src cpp
      void
      bind_vector_insert_obj (bind_vector_t &bind_vector,
                              shared_ptr <obj_t> obj)
      {
          auto begin = bind_vector.rbegin ();
          auto end = bind_vector.rend ();
          for (auto it = begin; it != end; it++) {
              if (it->second == nullptr) {
                  it->second = obj;
                  return;
              }
          }
          cout << "- fatal error ! bind_vector_insert_obj" << "\n"
               << "  the bind_vector is filled" << "\n"
               << "\n";
          exit (1);
      }
      #+end_src

***** bind_vector_merge_obj_vector

      #+begin_src cpp
      bind_vector_t
      bind_vector_merge_obj_vector (bind_vector_t &old_bind_vector,
                                    obj_vector_t &obj_vector)
      {
          auto bind_vector = old_bind_vector;
          for (auto obj: obj_vector)
              bind_vector_insert_obj (bind_vector, obj);
          return bind_vector;
      }
      #+end_src

***** pick_up_obj_vector

      #+begin_src cpp
      obj_vector_t
      pick_up_obj_vector (env_t &env, size_t counter)
      {
          auto obj_vector = obj_vector_t ();
          while (counter > 0) {
              counter--;
              auto obj = env.obj_stack.top ();
              obj_vector.push_back (obj);
              env.obj_stack.pop ();
          }
          reverse (obj_vector.begin (),
                   obj_vector.end ());
          return obj_vector;
      }
      #+end_src

***** local_scope_extend

      #+begin_src cpp
      local_scope_t
      local_scope_extend (local_scope_t old_local_scope,
                          bind_vector_t bind_vector)
      {
          auto local_scope = old_local_scope;
          local_scope.push_back (bind_vector);
          return local_scope;
      }
      #+end_src

***** lambda_o::apply

      #+begin_src cpp
      void
      lambda_o::apply (env_t &env, size_t arity)
      {
          auto size = this->lambda_jo->name_vector.size ();
          auto have = number_of_obj_in_bind_vector (this->bind_vector);
          auto lack = size - have;
          if (lack == arity) {
              auto obj_vector = pick_up_obj_vector
                  (env, arity);
              auto bind_vector = bind_vector_merge_obj_vector
                   (this->bind_vector, obj_vector);
              auto local_scope = local_scope_extend
                  (this->local_scope, bind_vector);
              auto frame = make_shared <frame_t>
                  (this->lambda_jo->jojo, local_scope);
              env.frame_stack.push (frame);
          }
          else if (arity < lack) {
              auto obj_vector = pick_up_obj_vector
                  (env, arity);
              auto bind_vector = bind_vector_merge_obj_vector
                  (this->bind_vector, obj_vector);
              auto lambda = make_shared <lambda_o>
                  (env,
                   this->lambda_jo,
                   bind_vector,
                   this->local_scope);
              env.obj_stack.push (lambda);
          }
          else {
              cout << "- fatal error : lambda_o::apply" << "\n"
                   << "  over-arity apply" << "\n"
                   << "  arity > lack" << "\n"
                   << "  arity : " << arity << "\n"
                   << "  lack : " << lack << "\n"
                   << "\n";
              exit (1);
          }
      }
      #+end_src

*** string

***** string_o

      #+begin_src cpp
      struct string_o: obj_t
      {
          string str;
          string_o (env_t &env, string str);
          void print (env_t &env);
      };
      #+end_src

***** string_o::string_o

      #+begin_src cpp
      string_o::string_o (env_t &env, string str)
      {
          this->tag = tagging (env, "string-t");
          this->str = str;
      }
      #+end_src

***** string_o::print

      #+begin_src cpp
      void string_o::print (env_t &env)
      {
          cout << '"' << this->str << '"';
      }
      #+end_src

*** data

***** data_o

      #+begin_src cpp
      struct data_o: obj_t
      {
          obj_map_t obj_map;
          data_o (env_t &env,
                  tag_t tag,
                  obj_map_t obj_map);
      };
      #+end_src

***** data_o::data_o

      #+begin_src cpp
      data_o::
      data_o (env_t &env,
              tag_t tag,
              obj_map_t obj_map)
      {
          this->tag = tag;
          this->obj_map = obj_map;
      }
      #+end_src

*** data_cons

***** data_cons_o

      #+begin_src cpp
      struct data_cons_o: obj_t
      {
          tag_t type_tag;
          name_vector_t name_vector;
          obj_map_t obj_map;
          data_cons_o (env_t &env,
                       tag_t type_tag,
                       name_vector_t name_vector,
                       obj_map_t obj_map);
          void apply (env_t &env, size_t arity);
      };
      #+end_src

***** data_cons_o::data_cons_o

      #+begin_src cpp
      data_cons_o::
      data_cons_o (env_t &env,
                   tag_t type_tag,
                   name_vector_t name_vector,
                   obj_map_t obj_map)
      {
          this->tag = tagging (env, "data-cons-t");
          this->type_tag = type_tag;
          this->name_vector = name_vector;
          this->obj_map = obj_map;
      }
      #+end_src

***** name_vector_obj_map_lack

      #+begin_src cpp
      name_vector_t
      name_vector_obj_map_lack (name_vector_t &old_name_vector,
                                obj_map_t &obj_map)
      {
          auto name_vector = name_vector_t ();
          for (auto name: old_name_vector) {
              auto it = obj_map.find (name);
              // not found == lack
              if (it == obj_map.end ())
                  name_vector.push_back (name);
          }
          return name_vector;
      }
      #+end_src

***** name_vector_obj_map_arity_lack

      #+begin_src cpp
      name_vector_t
      name_vector_obj_map_arity_lack (name_vector_t &old_name_vector,
                                      obj_map_t &obj_map,
                                      size_t arity)
      {
          auto name_vector = name_vector_obj_map_lack
              (old_name_vector, obj_map);
          auto lack = name_vector.size ();
          auto counter = lack - arity;
          while (counter > 0) {
              counter--;
              name_vector.pop_back ();
          }
          return name_vector;
      }
      #+end_src

***** data_cons_o::apply

      #+begin_src cpp
      void
      data_cons_o::apply (env_t &env, size_t arity)
      {
          auto size = this->name_vector.size ();
          auto have = this->obj_map.size ();
          auto lack = size - have;
          if (lack == arity) {
              auto lack_name_vector = name_vector_obj_map_lack
                  (this->name_vector, obj_map);
              auto obj_map = this->obj_map;
              auto begin = lack_name_vector.rbegin ();
              auto end = lack_name_vector.rend ();
              for (auto it = begin; it != end; it++) {
                  name_t name = *it;
                  auto obj = env.obj_stack.top ();
                  env.obj_stack.pop ();
                  obj_map [name] = obj;
              }
              auto data = make_shared <data_o>
                  (env,
                   this->type_tag,
                   obj_map);
              env.obj_stack.push (data);
          }
          else if (arity < lack) {
              auto lack_name_vector = name_vector_obj_map_arity_lack
                  (this->name_vector, obj_map, arity);
              auto obj_map = this->obj_map;
              auto begin = lack_name_vector.rbegin ();
              auto end = lack_name_vector.rend ();
              for (auto it = begin; it != end; it++) {
                  name_t name = *it;
                  auto obj = env.obj_stack.top ();
                  env.obj_stack.pop ();
                  obj_map [name] = obj;
              }
              auto data_cons = make_shared <data_cons_o>
                  (env,
                   this->type_tag,
                   this->name_vector,
                   obj_map);
              env.obj_stack.push (data_cons);
          }
          else {
              cout << "- fatal error : data_cons_o::apply" << "\n"
                   << "  over-arity apply" << "\n"
                   << "  arity > lack" << "\n"
                   << "  arity : " << arity << "\n"
                   << "  lack : " << lack << "\n"
                   << "\n";
              exit (1);
          }
      }
      #+end_src

* env

*** jojo

***** jojo_print

      #+begin_src cpp
      void
      jojo_print (env_t &env, jojo_t jojo)
      {
          for (auto &jo: jojo)
              cout << jo->repr (env) << " ";
      }
      #+end_src

***** jojo_print_with_index

      #+begin_src cpp
      void
      jojo_print_with_index (env_t &env, jojo_t jojo, size_t index)
      {
          for (auto it = jojo.begin ();
               it != jojo.end ();
               it++) {
              size_t it_index = it - jojo.begin ();
              jo_t *jo = *it;
              if (index == it_index) {
                  cout << "->> " << jo->repr (env) << " ";
              }
              else {
                  cout << jo->repr (env) << " ";
              }
          }
      }
      #+end_src

*** frame

***** frame_t::frame_t

      #+begin_src cpp
      frame_t::frame_t (jojo_t jojo, local_scope_t local_scope)
      {
          this->index = 0;
          this->jojo = jojo;
          this->local_scope = local_scope;
      }
      #+end_src

***** frame_report

      #+begin_src cpp
      void
      frame_report (env_t &env, shared_ptr <frame_t> frame)
      {
          cout << "  - ["
               << frame->index+1
               << "/"
               << frame->jojo.size ()
               << "] ";
          jojo_print_with_index (env, frame->jojo, frame->index);
          cout << "\n";

          cout << "  - local_scope # "
               << frame->local_scope.size ()
               << "\n";
      }
      #+end_src

*** box

***** box_t::box_t

      #+begin_src cpp
      box_t::box_t ()
      {
          this->empty_p = true;
      }

      box_t::box_t (shared_ptr <obj_t> obj)
      {
          this->empty_p = false;
          this->obj = obj;
      }
      #+end_src

***** boxing

      #+begin_src cpp
      box_t *
      boxing (env_t &env, name_t name)
      {
          auto it = env.box_map.find (name);
          if (it != env.box_map.end ())
              return it->second;
          else {
              auto box = new box_t ();
              env.box_map [name] = box;
              return box;
          }
      }
      #+end_src

*** box_map

***** box_map_report

      #+begin_src cpp
      void
      box_map_report (env_t &env)
      {
          cout << "- box_map # " << env.box_map.size () << "\n";
          for (auto &kv: env.box_map) {
              cout << "  " << kv.first << " : ";
              auto box = kv.second;
              box->obj->print (env);
              cout << "\n";
          }
      }
      #+end_src

*** obj_stack

***** frame_stack_report

      #+begin_src cpp
      void
      frame_stack_report (env_t &env)
      {
          cout << "- frame_stack # "
               << env.frame_stack.size ()
               << "\n";
          frame_stack_t frame_stack = env.frame_stack;
          while (! frame_stack.empty ()) {
             auto frame = frame_stack.top ();
             frame_report (env, frame);
             frame_stack.pop ();
          }
      }
      #+end_src

*** frame_stack

***** obj_stack_report

      #+begin_src cpp
      void
      obj_stack_report (env_t &env)
      {
          cout << "- obj_stack # "
               << env.obj_stack.size ()
               << "\n";
          cout << "  ";
          auto obj_stack = env.obj_stack;
          while (! obj_stack.empty ()) {
              auto obj = obj_stack.top ();
              obj->print (env);
              cout << " ";
              obj_stack.pop ();
          }
          cout << "\n";
      }
      #+end_src

*** env_t::step

    #+begin_src cpp
    void
    env_t::step ()
    {
        auto frame = this->frame_stack.top ();
        size_t size = frame->jojo.size ();
        size_t index = frame->index;
        // it is assumed that jojo in frame are not empty
        jo_t *jo = frame->jojo [index];
        frame->index++;
        // handle proper tail call
        if (index+1 == size) this->frame_stack.pop ();
        // since the last frame might be drop,
        //   we pass last local_scope as an extra argument.
        jo->exe (*this, frame->local_scope);
    }
    #+end_src

*** env_t::run

    #+begin_src cpp
    void
    env_t::run ()
    {
        while (!this->frame_stack.empty ()) {
            this->step ();
        }
    }
    #+end_src

*** env_t::report

    #+begin_src cpp
    void
    env_t::report ()
    {
        box_map_report (*this);
        frame_stack_report (*this);
        obj_stack_report (*this);
        cout << "\n";
    }
    #+end_src

* jo

*** jo

***** jo_t::exe

      #+begin_src cpp
      void
      jo_t::exe (env_t &env, local_scope_t &local_scope)
      {
          cout << "- fatal error : unknown jo" << "\n";
          exit (1);
      }
      #+end_src

***** jo_t::repr

      #+begin_src cpp
      string
      jo_t::repr (env_t &env)
      {
          return "(unknown)";
      }
      #+end_src

*** ref_jo

***** ref_jo_t

      #+begin_src cpp
      struct ref_jo_t: jo_t
      {
          box_t *box;
          ref_jo_t (box_t *box);
          void exe (env_t &env, local_scope_t &local_scope);
          string repr (env_t &env);
      };
      #+end_src

***** ref_jo_t::ref_jo_t

      #+begin_src cpp
      ref_jo_t::ref_jo_t (box_t *box)
      {
          this->box = box;
      }
      #+end_src

***** ref_jo_t::exe

      #+begin_src cpp
      void
      ref_jo_t::exe (env_t &env, local_scope_t &local_scope)
      {
          assert (! this->box->empty_p);
          env.obj_stack.push (this->box->obj);
      }
      #+end_src

***** ref_jo_t::repr

      #+begin_src cpp
      string
      ref_jo_t::repr (env_t &env)
      {
          // return "(ref " + this->name + ")";
          return "(ref)";
      }
      #+end_src

*** local_ref_jo

***** local_ref_jo_t

      #+begin_src cpp
      struct local_ref_jo_t: jo_t
      {
          size_t level;
          size_t index;
          local_ref_jo_t (size_t level, size_t index);
          void exe (env_t &env, local_scope_t &local_scope);
          string repr (env_t &env);
      };
      #+end_src

***** local_ref_jo_t::local_ref_jo_t

      #+begin_src cpp
      local_ref_jo_t::
      local_ref_jo_t (size_t level, size_t index)
      {
          this->level = level;
          this->index = index;
      }
      #+end_src

***** vector_rev_ref

      #+begin_src cpp
      template <class T>
      T
      vector_rev_ref (vector <T> vect, size_t rev_index)
      {
          size_t size = vect.size ();
          size_t index = size - rev_index - 1;
          return vect [index];
      }
      #+end_src

***** local_ref_jo_t::exe

      #+begin_src cpp
      void
      local_ref_jo_t::exe (env_t &env, local_scope_t &local_scope)
      {
          // this is the only place where
          //   the local_scope in the arg of exe is uesd.
          auto bind_vector =
              vector_rev_ref (local_scope, this->level);
          auto bind =
              vector_rev_ref (bind_vector, this->index);
          // {
          //     local_scope_print (env, local_scope);
          //     cout << "- local_ref_jo_t::exe\n"
          //          << "  this->level : " << this->level << "\n"
          //          << "  this->index : " << this->index << "\n"
          //          << "  bind.first : " << bind.first << "\n";
          //     cout << "  bind.second->print () : ";
          //     bind.second->print (env);
          //     cout << "\n";
          //     cout << "\n";
          // }
          auto obj = bind.second;
          env.obj_stack.push (obj);
      }
      #+end_src

***** local_ref_jo_t::repr

      #+begin_src cpp
      string
      local_ref_jo_t::repr (env_t &env)
      {
          return "(local-ref " +
              to_string (this->level) + " " +
              to_string (this->index) + ")";
      }
      #+end_src

*** lambda_jo

***** lambda_jo_t::lambda_jo_t

      #+begin_src cpp
      lambda_jo_t::lambda_jo_t (name_vector_t name_vector, jojo_t jojo)
      {
          this->name_vector = name_vector;
          this->jojo = jojo;
      }
      #+end_src

***** bind_vector_from_name_vector

      #+begin_src cpp
      bind_vector_t
      bind_vector_from_name_vector (name_vector_t &name_vector)
      {
          auto bind_vector = bind_vector_t ();
          auto begin = name_vector.begin ();
          auto end = name_vector.end ();
          for (auto it = begin; it != end; it++)
              bind_vector.push_back (make_pair (*it, nullptr));
          return bind_vector;
      }
      #+end_src

***** lambda_jo_t::exe

      #+begin_src cpp
      void
      lambda_jo_t::exe (env_t &env, local_scope_t &local_scope)
      {
          auto frame = env.frame_stack.top ();
          auto lambda = make_shared <lambda_o>
              (env, this,
               bind_vector_from_name_vector (this->name_vector),
               frame->local_scope);
          env.obj_stack.push (lambda);
      }
      #+end_src

***** lambda_jo_t::repr

      #+begin_src cpp
      string
      lambda_jo_t::repr (env_t &env)
      {
          return "(lambda)";
      }
      #+end_src

*** field_jo

***** field_jo_t

      #+begin_src cpp
      struct field_jo_t: jo_t
      {
          name_t name;
          field_jo_t (name_t name);
          void exe (env_t &env, local_scope_t &local_scope);
          string repr (env_t &env);
      };
      #+end_src

***** field_jo_t::field_jo_t

      #+begin_src cpp
      field_jo_t::field_jo_t (name_t name)
      {
          this->name = name;
      }
      #+end_src

***** field_jo_t::exe

      #+begin_src cpp
      void
      field_jo_t::exe (env_t &env, local_scope_t &local_scope)
      {
          auto obj = env.obj_stack.top ();
          env.obj_stack.pop ();
          auto data = static_pointer_cast <data_o> (obj);
          auto it = data->obj_map.find (this->name);
          if (it != data->obj_map.end ()) {
              env.obj_stack.push (it->second);
              return;
          }
          cout << "- fatal error ! unknown field : "
               << this->name
               << "\n";
          exit (1);
      }
      #+end_src

***** field_jo_t::repr

      #+begin_src cpp
      string
      field_jo_t::repr (env_t &env)
      {
          return "(field " + this->name + ")";
      }
      #+end_src

*** apply_jo

***** apply_jo_t

      #+begin_src cpp
      struct apply_jo_t: jo_t
      {
          size_t arity;
          apply_jo_t (size_t arity);
          void exe (env_t &env, local_scope_t &local_scope);
          string repr (env_t &env);
      };
      #+end_src

***** apply_jo_t::apply_jo_t

      #+begin_src cpp
      apply_jo_t::
      apply_jo_t (size_t arity)
      {
          this->arity = arity;
      }
      #+end_src

***** apply_jo_t::exe

      #+begin_src cpp
      void
      apply_jo_t::exe (env_t &env, local_scope_t &local_scope)
      {
          auto obj = env.obj_stack.top ();
          env.obj_stack.pop ();
          obj->apply (env, this->arity);
      }
      #+end_src

***** apply_jo_t::repr

      #+begin_src cpp
      string
      apply_jo_t::repr (env_t &env)
      {
          return "(apply)";
      }
      #+end_src

* epilog

*** test

***** test_step

      #+begin_src cpp
      void
      test_step ()
      {
          auto env = env_t ();

          env.box_map = {
              {"string-1", new box_t (make_shared <string_o> (env, "bye"))},
              {"string-2", new box_t (make_shared <string_o> (env, "world"))},
          };

          jojo_t jojo = {
              new ref_jo_t (boxing (env, "string-1")),
              new ref_jo_t (boxing (env, "string-2")),
          };
          auto frame = make_shared <frame_t> (jojo, local_scope_t ());
          env.frame_stack.push (frame);
          env.run ();

          assert (env.obj_stack.size () == 2);

          auto string_2 = static_pointer_cast <string_o>
              (env.obj_stack.top ());
          assert (string_2->tag == tagging (env, "string-t"));
          assert (string_2->str == "world");
          env.obj_stack.pop ();

          assert (env.obj_stack.size () == 1);

          auto string_1 = static_pointer_cast <string_o>
              (env.obj_stack.top ());
          assert (string_1->tag == tagging (env, "string-t"));
          assert (string_1->str == "bye");
          env.obj_stack.pop ();

          assert (env.obj_stack.size () == 0);
      }
      #+end_src

***** test_data

      #+begin_src cpp
      void
      test_data ()
      {
          auto env = env_t ();

          obj_map_t obj_map = {
              {"field-1", make_shared <string_o> (env, "bye")},
              {"field-2", make_shared <string_o> (env, "world")},
          };

          env.box_map = {
              {"data-1", new box_t (make_shared <data_o> (env, tagging (env, "data-1-t"), obj_map))},
          };

          jojo_t jojo = {
              new ref_jo_t (boxing (env, "data-1")),
              new field_jo_t ("field-1"),
              new ref_jo_t (boxing (env, "data-1")),
              new field_jo_t ("field-2"),
              new ref_jo_t (boxing (env, "data-1")),
          };
          auto frame = make_shared <frame_t> (jojo, local_scope_t ());
          env.frame_stack.push (frame);
          env.run ();

          assert (env.obj_stack.size () == 3);

          auto data_1 = static_pointer_cast <data_o>
              (env.obj_stack.top ());
          assert (data_1->tag == tagging (env, "data-1-t"));
          env.obj_stack.pop ();

          assert (env.obj_stack.size () == 2);

          auto string_2 = static_pointer_cast <string_o>
              (env.obj_stack.top ());
          assert (string_2->tag == tagging (env, "string-t"));
          assert (string_2->str == "world");
          env.obj_stack.pop ();

          assert (env.obj_stack.size () == 1);

          auto string_1 = static_pointer_cast <string_o>
              (env.obj_stack.top ());
          assert (string_1->tag == tagging (env, "string-t"));
          assert (string_1->str == "bye");
          env.obj_stack.pop ();

          assert (env.obj_stack.size () == 0);
      }
      #+end_src

***** test_apply

      #+begin_src cpp
      void
      test_apply ()
      {
          auto env = env_t ();

          env.box_map = {
              {"string-1", new box_t (make_shared <string_o> (env, "bye"))},
              {"string-2", new box_t (make_shared <string_o> (env, "world"))},
          };

          jojo_t jojo = {
              new ref_jo_t (boxing (env, "string-1")),
              new ref_jo_t (boxing (env, "string-2")),
              new lambda_jo_t ({ "x", "y" },
                               { new local_ref_jo_t (0, 0),
                                 new local_ref_jo_t (0, 1) }),
              new apply_jo_t (2),
          };
          auto frame = make_shared <frame_t> (jojo, local_scope_t ());
          env.frame_stack.push (frame);

          // {
          //     env.report ();
          //     env.run ();
          //     env.report ();
          // }

          {
              env.run ();

              assert (env.obj_stack.size () == 2);

              auto string_2 = static_pointer_cast <string_o>
                  (env.obj_stack.top ());
              assert (string_2->tag == tagging (env, "string-t"));
              assert (string_2->str == "world");
              env.obj_stack.pop ();

              assert (env.obj_stack.size () == 1);

              auto string_1 = static_pointer_cast <string_o>
                  (env.obj_stack.top ());
              assert (string_1->tag == tagging (env, "string-t"));
              assert (string_1->str == "bye");
              env.obj_stack.pop ();

              assert (env.obj_stack.size () == 0);
          }
      }
      #+end_src

***** test_lambda_curry

      #+begin_src cpp
      void
      test_lambda_curry ()
      {
          auto env = env_t ();

          env.box_map = {
              {"string-1", new box_t (make_shared <string_o> (env, "bye"))},
              {"string-2", new box_t (make_shared <string_o> (env, "world"))},
          };

          jojo_t jojo = {
              new ref_jo_t (boxing (env, "string-1")),
              new ref_jo_t (boxing (env, "string-2")),
              new lambda_jo_t ({ "x", "y" },
                               { new local_ref_jo_t (0, 0),
                                 new local_ref_jo_t (0, 1) }),
              new apply_jo_t (1),
              new apply_jo_t (1),
          };
          auto frame = make_shared <frame_t> (jojo, local_scope_t ());
          env.frame_stack.push (frame);

          // {
          //     env.report ();
          //     env.run ();
          //     env.report ();
          // }

          {
              env.run ();

              assert (env.obj_stack.size () == 2);

              auto string_1 = static_pointer_cast <string_o>
                  (env.obj_stack.top ());
              assert (string_1->tag == tagging (env, "string-t"));
              assert (string_1->str == "bye");
              env.obj_stack.pop ();

              assert (env.obj_stack.size () == 1);

              auto string_2 = static_pointer_cast <string_o>
                  (env.obj_stack.top ());
              assert (string_2->tag == tagging (env, "string-t"));
              assert (string_2->str == "world");
              env.obj_stack.pop ();

              assert (env.obj_stack.size () == 0);
          }
      }
      #+end_src

***** test_data_cons

      #+begin_src cpp
      void
      test_data_cons ()
      {
          auto env = env_t ();

          name_vector_t name_vector = { "field-1", "field-2" };
          env.box_map = {
              {"string-1", new box_t (make_shared <string_o> (env, "bye"))},
              {"string-2", new box_t (make_shared <string_o> (env, "world"))},
              {"data-1-c", new box_t
               (make_shared <data_cons_o>
                (env,
                 tagging (env, "data-1-t"),
                 name_vector,
                 obj_map_t ()))},
          };

          jojo_t jojo = {
              new ref_jo_t (boxing (env, "string-1")),
              new ref_jo_t (boxing (env, "string-2")),
              new ref_jo_t (boxing (env, "data-1-c")),
              new apply_jo_t (2),
              new field_jo_t ("field-2"),
          };
          auto frame = make_shared <frame_t> (jojo, local_scope_t ());
          env.frame_stack.push (frame);

          // {
          //     env.report ();
          //     env.run ();
          //     env.report ();
          // }

          {
              env.run ();

              assert (env.obj_stack.size () == 1);

              auto string_2 = static_pointer_cast <string_o>
                  (env.obj_stack.top ());
              assert (string_2->tag == tagging (env, "string-t"));
              assert (string_2->str == "world");
              env.obj_stack.pop ();

              assert (env.obj_stack.size () == 0);
          }
      }
      #+end_src

***** test_data_cons_curry

      #+begin_src cpp
      void
      test_data_cons_curry ()
      {
          auto env = env_t ();

          name_vector_t name_vector = { "field-1", "field-2" };
          env.box_map = {
              {"string-1", new box_t (make_shared <string_o> (env, "bye"))},
              {"string-2", new box_t (make_shared <string_o> (env, "world"))},
              {"data-1-c", new box_t
               (make_shared <data_cons_o>
                (env,
                 tagging (env, "data-1-t"),
                 name_vector,
                 obj_map_t ()))},
          };

          jojo_t jojo = {
              new ref_jo_t (boxing (env, "string-1")),
              new ref_jo_t (boxing (env, "string-2")),
              new ref_jo_t (boxing (env, "data-1-c")),
              new apply_jo_t (1),
              new apply_jo_t (1),
              new field_jo_t ("field-1"),
          };
          auto frame = make_shared <frame_t> (jojo, local_scope_t ());
          env.frame_stack.push (frame);

          // {
          //     env.report ();
          //     env.run ();
          //     env.report ();
          // }

          {
              env.run ();

              assert (env.obj_stack.size () == 1);

              auto string_2 = static_pointer_cast <string_o>
                  (env.obj_stack.top ());
              assert (string_2->tag == tagging (env, "string-t"));
              assert (string_2->str == "world");
              env.obj_stack.pop ();

              assert (env.obj_stack.size () == 0);
          }
      }
      #+end_src

***** test_all

      #+begin_src cpp
      void
      test_all ()
      {
          test_step ();
          test_data ();
          test_apply ();
          test_lambda_curry ();
          test_data_cons ();
          test_data_cons_curry ();
      }
      #+end_src

*** main

    #+begin_src cpp
    int
    main ()
    {
        test_all ();
        return 0;
    }
    #+end_src
