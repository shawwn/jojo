#+property: tangle main.rs
#+title: jojo

* prolog

*** feature

    #+begin_src rust
    #![feature(nll)]
    #+end_src

*** use

    #+begin_src rust
    use std::collections::HashMap;
    use std::rc::Rc;
    #+end_src

* datatype

  #+begin_src rust
  type Name = String;

  type ObjRecord = Vec <(Name, Rc <Obj>)>;
  type ObjRef = usize; // index in to ObjRecord

  type TypeRecord = Vec <(Name, Rc <Type>)>;
  type Tag = usize; // index in to TypeRecord
  type TagMap = HashMap <Tag, Name>;

  type JoVec = Vec <Rc <Jo>>;

  type ObjStack = Vec <Rc <Obj>>;

  type Bind = (Name, Rc <Obj>);
  type BindVec = Vec <Bind>; // index from end
  type LocalScope = Vec <BindVec>; // index from end

  type FrameStack = Vec <Box <Frame>>;
  #+end_src

* utility

* obj

*** Obj

    #+begin_src rust
    trait Obj
    {
        fn tag (&self) -> Tag;
        fn obj_map (&self) -> HashMap <Name, Rc <Obj>>;
        fn repr (&self, env: &Env) -> String;
        fn print (&self, env: &Env);
        fn eq (&self, env: &Env, obj: Rc <Obj>) -> bool;
        fn apply (&self, env: &Env, arity: usize);
        fn apply_to_arg_dict (&self, env: &Env);
    }
    #+end_src

*** define

*** obj_eq

    #+begin_src rust

    #+end_src

* jo

*** Jo

    #+begin_src rust
    trait Jo
    {
        fn exe (&self, env: &mut Env, local_scope: Rc <LocalScope>);
        fn repr (&self, env: &Env) -> String;
    }
    #+end_src

* frame

*** Frame

    #+begin_src rust
    struct Frame
    {
        index: usize,
        jojo: Rc <JoVec>,
        local_scope: Rc <LocalScope>,
    }
    #+end_src

* env

*** Env

    #+begin_src rust
    struct Env
    {
        obj_record: ObjRecord,
        obj_stack: ObjStack,
        frame_stack: FrameStack,
        type_record: TypeRecord,
        tag_map: TagMap,
    }
    #+end_src

*** env_step

    #+begin_src rust
    fn env_step (env: &mut Env)
    {
        if let Some(mut frame) = env.frame_stack.pop ()
        {
            let jo = frame.jojo [frame.index] .clone ();
            frame.index += 1;
            if frame.index < frame.jojo.len () {
                let local_scope = frame.local_scope.clone ();
                env.frame_stack.push (frame);
                jo.exe (env, local_scope);
            }
            else {
                jo.exe (env, frame.local_scope);
            }
        }
    }
    #+end_src

*** env_run

    #+begin_src rust
    fn env_run (env: &mut Env)
    {
        while ! env.frame_stack.is_empty () {
            env_step (env);
        }
    }
    #+end_src

*** env_run_with_base

    #+begin_src rust
    fn env_run_with_base (env: &mut Env, base: usize)
    {
        while env.frame_stack.len () > base {
            env_step (env);
        }
    }
    #+end_src

* data

* prim

* scan

* sexp

* compile

* run

* epilog

*** main

    #+begin_src rust
    fn main ()
    {
        println! ("jojo!");
    }
    #+end_src
