#+property: tangle jojo.cpp
#+title: jojo

* [todo-stack]

*** obj_apply

*** exe

*** env_t::report

*** eval

* [note]

*** [for now] use string instead of symbol

    - to simplify the implementation
      we use string instead of symbol
      and we keep the implementation easy to change
      and add symbol back only later

* prolog

*** include

    #+begin_src cpp
    #include <iostream>
    #include <vector>
    #include <map>
    #include <set>
    #include <stack>
    #+end_src

*** using

    #+begin_src cpp
    using namespace std;
    #+end_src

* datatype

*** name_t

    #+begin_src cpp
    using name_t = string;
    #+end_src

*** ins

***** ins_t

      #+begin_src cpp
      struct env_t;
      struct obj_t;

      struct ins_t
      {
          virtual
          void exe (env_t &env, map<name_t, obj_t *> &local_map);
      };
      #+end_src

***** call_ins_t

      #+begin_src cpp
      struct call_ins_t: public ins_t
      {
          name_t name;
          void exe (env_t &env, map<name_t, obj_t *> &local_map);
      };
      #+end_src

***** let_ins_t

      #+begin_src cpp
      struct let_ins_t: public ins_t
      {
          name_t name;
          void exe (env_t &env, map<name_t, obj_t *> &local_map);
      };
      #+end_src

***** lambda_ins_t

      #+begin_src cpp
      struct lambda_ins_t: public ins_t
      {
          vector<ins_t *> body;
          void exe (env_t &env, map<name_t, obj_t *> &local_map);
      };
      #+end_src

*** obj

***** obj_t

      #+begin_src cpp
      struct obj_t
      {
          string tagstr;
      };
      #+end_src

***** lambda_obj_t

      #+begin_src cpp
      struct lambda_obj_t: public obj_t
      {
          map<name_t, obj_t *> local_map;
          vector<ins_t *> body;
      };
      #+end_src

***** int_obj_t

      #+begin_src cpp
      struct int_obj_t: public obj_t
      {
          int i;
      };
      #+end_src

***** str_obj_t

      #+begin_src cpp
      struct str_obj_t: public obj_t
      {
          string s;
      };
      #+end_src

*** frame_t

    #+begin_src cpp
    struct frame_t
    {
       size_t index;
       vector<ins_t *> body;
       map<name_t, obj_t *> local_map;
    };
    #+end_src

*** env_t

    #+begin_src cpp
    struct env_t
    {
        map<name_t, obj_t *> name_map;
        stack<obj_t *> obj_stack;
        stack<frame_t *> frame_stack;
        void step ();
        void report ();
        void eval ();
    };
    #+end_src

* env

*** env_t::step

    #+begin_src cpp
    void env_t::step ()
    {
        frame_t *frame = this->frame_stack.top ();
        size_t size = frame->body.size ();
        size_t index = frame->index;

        // handle empty function body
        if (index >= size) {
            this->frame_stack.pop ();
            return;
        }

        // get ins only for non empty function body
        ins_t *ins = frame->body[index];

        frame->index++;

        // handle proper tail call
        if (index+1 == size)
            frame_stack.pop ();

        // since the last frame might be drop,
        //   we pass local_map the last frame
        //   as an extra argument.
        ins->exe (*this, frame->local_map);
    }
    #+end_src

*** env_t::report

    #+begin_src cpp
    void env_t::report ()
    {
        cout << "- name_map : "
             << this->name_map.size () << "\n";
        cout << "- obj_stack : "
             << this->obj_stack.size () << "\n";
        cout << "- frame_stack : "
             << this->frame_stack.size () << "\n";
        cout << "\n";
    }
    #+end_src

*** >< env_t::eval

    #+begin_src cpp
    void env_t::eval ()
    {

    }
    #+end_src

* ins

*** ins_t::exe

    #+begin_src cpp
    void ins_t::exe (env_t &env, map<name_t, obj_t *> &local_map)
    {
        cout << "fatal error : unknown ins" << "\n";
    }
    #+end_src

*** >< obj_apply

    #+begin_src cpp
    void obj_apply (env_t &env, obj_t &obj)
    {
        // apply lambda
        // ><><><

        // push non lambda into obj_stack
        env.obj_stack.push (&obj);
    }
    #+end_src

*** call_ins_t::exe

    #+begin_src cpp
    void call_ins_t::exe (env_t &env, map<name_t, obj_t *> &local_map)
    {
        // local_map first
        auto it = local_map.find (this->name);
        if (it != local_map.end ()) {
            obj_apply (env, *(it->second));
            return;
        }
        // name_map second
        it = env.name_map.find (this->name);
        if (it != env.name_map.end ()) {
            obj_apply (env, *(it->second));
            return;
        }
        cout << "fatal error ! unknown name : "
             << this->name
             << "\n";
    }
    #+end_src

*** let_ins_t::exe

    #+begin_src cpp
    void let_ins_t::exe (env_t &env, map<name_t, obj_t *> &local_map)
    {
         obj_t *obj = env.obj_stack.top ();
         env.obj_stack.pop ();
         local_map.insert (pair<name_t, obj_t *> (this->name, obj));
    }
    #+end_src

*** >< lambda_ins_t::exe

    #+begin_src cpp
    void lambda_ins_t::exe (env_t &env, map<name_t, obj_t *> &local_map)
    {
         // create lambda_obj_t by closure

    }
    #+end_src

* epilog

*** main

    #+begin_src cpp
    int main ()
    {
        env_t env;

        str_obj_t s1;
        s1.tagstr = "string-t";
        s1.s = "s1";

        str_obj_t s2;
        s2.tagstr = "string-t";
        s2.s = "s2";

        env.name_map.insert (pair<name_t, obj_t *> ("k1", &s1));
        env.name_map.insert (pair<name_t, obj_t *> ("k2", &s2));

        frame_t frame;
        frame.index = 0;

        call_ins_t call_k1;
        call_k1.name = "k1";

        call_ins_t call_k2;
        call_k2.name = "k2";

        let_ins_t let_v;
        let_v.name = "v";

        call_ins_t call_v;
        call_v.name = "v";

        frame.body.push_back (&call_k1);
        frame.body.push_back (&call_k2);

        frame.body.push_back (&let_v);
        frame.body.push_back (&call_v);
        frame.body.push_back (&call_v);

        env.frame_stack.push (&frame);

        env.report ();

        env.step ();
        env.report ();

        env.step ();
        env.report ();

        env.step ();
        env.report ();

        env.step ();
        env.report ();

        env.step ();
        env.report ();
    }
    #+end_src
