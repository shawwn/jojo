#+property: tangle main.rs
#+title: jojo

* prolog

*** feature

    #+begin_src rust
    #![feature(nll)]
    #+end_src

*** use

    #+begin_src rust
    use std::collections::HashMap;
    use std::rc::Rc;
    #+end_src

* datatype

  #+begin_src rust
  type Ptr <T> = Rc <T>;

  type Name = String;

  type ObjRecord = Vec <(Name, Ptr <Obj>)>;
  type ObjRef = usize; // index in to ObjRecord

  type TypeRecord = Vec <(Name, Ptr <Type>)>;
  type Tag = usize; // index in to TypeRecord
  type TagMap = HashMap <Tag, Name>;

  type JoVec = Vec <Ptr <Jo>>;

  type ObjStack = Vec <Ptr <Obj>>;

  type Bind = (Name, Ptr <Obj>);
  type BindVec = Vec <Bind>; // index from end
  type LocalScope = Vec <BindVec>; // index from end

  type FrameStack = Vec <Box <Frame>>;

  type StringVec = Vec <String>;
  #+end_src

* utility

* obj

*** Obj

    #+begin_src rust
    trait Obj {
        fn tag (&self) -> Tag;
        fn obj_map (&self) -> HashMap <Name, Ptr <Obj>>;
        fn repr (&self, env: &Env) -> String;
        fn print (&self, env: &Env);
        fn eq (&self, env: &Env, obj: Ptr <Obj>) -> bool;
        fn apply (&self, env: &Env, arity: usize);
        fn apply_to_arg_dict (&self, env: &Env);
    }
    #+end_src

* jo

*** Jo

    #+begin_src rust
    trait Jo {
        fn exe (&self, env: &mut Env, local_scope: Ptr <LocalScope>);
        fn repr (&self, env: &Env) -> String;
    }
    #+end_src

* frame

*** Frame

    #+begin_src rust
    struct Frame {
        index: usize,
        jojo: Ptr <JoVec>,
        local_scope: Ptr <LocalScope>,
    }
    #+end_src

* env

*** Env

    #+begin_src rust
    struct Env {
        obj_record: ObjRecord,
        obj_stack: ObjStack,
        frame_stack: FrameStack,
        type_record: TypeRecord,
        tag_map: TagMap,
    }
    #+end_src

*** env_step

    #+begin_src rust
    fn env_step (env: &mut Env) {
        if let Some (mut frame) = env.frame_stack.pop () {
            let jo = frame.jojo [frame.index] .clone ();
            frame.index += 1;
            if frame.index < frame.jojo.len () {
                let local_scope = frame.local_scope.clone ();
                env.frame_stack.push (frame);
                jo.exe (env, local_scope);
            }
            else {
                jo.exe (env, frame.local_scope);
            }
        }
    }
    #+end_src

*** env_run

    #+begin_src rust
    fn env_run (env: &mut Env) {
        while ! env.frame_stack.is_empty () {
            env_step (env);
        }
    }
    #+end_src

*** env_run_with_base

    #+begin_src rust
    fn env_run_with_base (env: &mut Env, base: usize) {
        while env.frame_stack.len () > base {
            env_step (env);
        }
    }
    #+end_src

* type

*** Type

    #+begin_src rust
    struct Type {

    }
    #+end_src

* data

* prim

* scan

*** space_char_p

    #+begin_src rust
    fn space_char_p (c: char) -> bool {
        (c == ' ' ||
         c == '\n' ||
         c == '\t')
    }
    #+end_src

*** delimiter_char_p

    #+begin_src rust
    fn delimiter_char_p (c: char) -> bool {
        (c == '(' ||
         c == ')' ||
         c == '[' ||
         c == ']' ||
         c == '{' ||
         c == '}' ||
         c == ',' ||
         c == '`' ||
         c == '\'')
    }
    #+end_src

*** semicolon_char_p

    #+begin_src rust
    fn semicolon_char_p (c: char) -> bool {
        (c == ';')
    }
    #+end_src

*** newline_char_p

    #+begin_src rust
    fn newline_char_p (c: char) -> bool {
        (c == '\n')
    }
    #+end_src

*** doublequote_char_p

    #+begin_src rust
    fn doublequote_char_p (c: char) -> bool {
        (c == '"')
    }
    #+end_src

*** scan_word_vector

    #+begin_src rust
    fn scan_word_vector (code: &str) -> StringVec {
        let mut word_vector = StringVec::new ();
        let mut iter = code.chars () .peekable ();
        while iter.peek () != None {
            if let Some (c) = iter.next () {
                if space_char_p (c) {
                }
                else if delimiter_char_p (c) {
                    let mut word = String::from ("");
                    word.push (c);
                    word_vector.push (word);
                }
                else if semicolon_char_p (c) {
                    loop {
                        if let Some (c) = iter.next () {
                            if newline_char_p (c) {
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
                else if doublequote_char_p (c) {
                    let mut word = String::from ("");
                    word.push (c);
                    loop {
                        if let Some (c) = iter.next () {
                            word.push (c);
                            if doublequote_char_p (c) {
                                break;
                            }
                        }
                        else {
                            // error
                        }
                    }
                    word_vector.push (word);
                }
                else {
                    let mut word = String::from ("");
                    word.push (c);
                    loop {
                        if let Some (c) = iter.peek () {
                            let c = *c;
                            if (space_char_p (c) ||
                                doublequote_char_p (c) ||
                                semicolon_char_p (c) ||
                                delimiter_char_p (c))
                            {
                                break;
                            }
                            word.push (c);
                            iter.next ();
                        }
                        else {
                            iter.next ();
                            break;
                        }
                    }
                    word_vector.push (word);
                }
            }
        }
        word_vector
    }
    #+end_src

* sexp

* compile

* run

* epilog

*** main

    #+begin_src rust
    fn main() {
        println! ("{:#?}", scan_word_vector ("(a (a b c) b c)"));
    }
    #+end_src
